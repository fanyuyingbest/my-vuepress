# 9.树和二叉树：如何实现增删改查

### 9-1 树是什么

> 树是由结点和边组成的，不存在环的一种数据结构

![图示](/img/2020/algorithm/data9-1.jpg)

>树满足递归定义的特性，也就是说，如果一个数据结构是树，那么剔除根结点后，得到的若干子结构也是树，通常称为子树


- A结点是B结点和C结点的上级，则A就是B和C的父结点，B和C是A的子结点
- B和C 同时是A的‘孩子’，则可称为B和C互为兄弟结点
- A没有父结点，则A被称为根结点
- G、H、I、F结点都没有子结点，则称G、H、I、F为叶子结点

![图示](/img/2020/algorithm/data9-2.jpg)

> 但有了一颗树，还需要用深度、层来描述这棵树中结点的位置。结点的层级从根结点算起，根为第一层，根的‘孩子’为第二层，根的‘孩子’的‘孩子’为第三层，依次类推，树中结点最大层次数，就是这棵树的树深(称为深度也称为高度)，如上图所示，这就是一颗深度为4的树

### 9-2 二叉树是什么

> 在树的大家族中，有一种被高频使用的特殊树，这种就是二叉树。在二叉树中，每个结点最多有两个分支，即每个结点最多两个子结点，分别称为左子结点，右子结点。在二叉树中，有，两个特殊的类型

- 满二叉树，定义为除了叶子结点外，所有结点都有2个子结点
- 完全二叉树，定义为，除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列

![图示](/img/2020/algorithm/data9-3.jpg)

> 为什么完全二叉树看起来并不完全，还这样称呼？这个和二长树的存储有关，存储二叉树有两种办法，一种是指针的链式储存，一种是分别存放指向左右子结点的指针：

- 链式存储法，也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针，如图：

![图示](/img/2020/algorithm/data9-5.jpg)

- 顺序存储法，就是按照规律把结点存放在数组里，为了方便计算，我们会把根结点放在位置1的地方，随后，B结点存放在下标为2的位置，C放到3的位置，以此类推，就会发现规律：X的下标为i,X左侧的结点就是2*i,X右子结点总是存放在2*i+1的位置

> 之所以称为完全二叉树，是从存储空间利用效率视角来看的，对于一颗完全二叉树而言，仅仅浪费了下标为0的存储位置。而如果是一颗非完全二叉树，则会浪费大量储存空间。

> 如下图所示，它既需要保留5和6的位置，同时也需要保留5的两个子结点10和11的位置，以及6的两个子结点12和13的位置，没有完全利用好数组的存储空间

![图示](/img/2020/algorithm/data9-6.jpg)

### 9-3 树的基本操作

> 链表、栈、队列都是‘一对一’的关系，但树是‘一对多’的关系<br/>
> 在‘一对一’对结构总，直接顺序访问，在‘一对多’的关系，我们要怎么去遍历并保证没有遗漏<br/>
> 其实遍历一棵树，有经典三种方法，分别是前序遍历、中序遍历、后序遍历。这里的序指的是父结点的遍历顺序，前序就是先遍历父结点，中序就是中间遍历父结点，后序就是最后遍历父结点。不管哪种遍历，都是通过递归完成的。

- 前序遍历，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树
- 中序遍历，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树
- 后序遍历，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身

![图示](/img/2020/algorithm/data9-7.jpg)

> 下面用代码来实现遍历过程

```
 //先序排列
 function preOrderTraverse(node){
   if(node == null){
     return
   }
   Document.write(node.data + ' ');
   preOrderTraverse(node.left);
   preOrderTraverse(node.right)
 }

 //中序排列
 function inOrderTraverse(node){
   if(node == null){
     return
   }
   inOrderTraverse(node.left);
   Document.write(node.data + ' ');
   inOrderTraverse(node.right);
 }

 //中序排列
 function postOrderTraverse(node){
   if(node == null){
     return
   }
   postOrderTraverse(node.left);
   postOrderTraverse(node.right);
   Document.write(node.data + ' ');
 }
```

> 不难发现，每个结点都被访问了一次，所以其时间复杂度为O(n)；<br/>
> 找到位置之后执行删除操作，我们需要通过指针建立连接关系就可以了。<br/>
> 对于没有任何特殊性质的二叉树而言，抛开遍历的时间复杂度，真正执行增加删除操作的时间复杂度为O(1)<br/>
> 树数据的查找操作和链表一样，都需要遍历数据去判断，所以时间复杂度为O(n)<br/>


